DROP SCHEMA public CASCADE;
CREATE SCHEMA public;
create extension if not exists ltree;

create table if not exists users (
    /*secret_info*/
    user_id bigserial primary key,
	email text not null,
	token bytea not null,
	first_name text not null check ( length(first_name) > 0 ),
	last_name text not null check ( length(last_name) > 0),
    sex char(1) not null check ( sex in ('М', 'Ж')),
    /*basic_info*/
    avatar_ref text default 'hash_path/def_avatar.jpg', /*исправить путь*/
    bg_ref text default 'hash_path/def_bg',
	tel decimal(20),
	city text default '',
	birthday date, /*обработать*/
	status int2 check (0 <= status and status <= 5) default 0, /*0-не указано 1 1-женат 2-не женат 3-влюблен 4-все сложно 5-в акт.поиске */

    /*hobbies*/
	hobby text default '',
	fav_music text default '',
	fav_films text default '',
	fav_books text default '',
	fav_games text default '',
	other_interests text default '',

	/*privacy*/
	who_can_message text not null default 'all' check(who_can_message in ('all','fo')), /*fo - friends only*/
	who_can_see_info text not null default 'all' check(who_can_see_info in ('all','fo')),

    /*edu_and_emp*/
    edu_and_emp_info jsonb
); create index if not exists users_user_id_idx on users (user_id);


create table if not exists objects(
    obj_id bigserial primary key,
    auth_id bigint references users (user_id) on delete cascade,
    path ltree not null,
    text text not null,
    num_likes integer default 0 not null,
    creation_time      timestamptz default current_timestamp,
    modification_time   timestamptz
);
create index if not exists object_obj_id_idx on objects (obj_id);
create index if not exists object_path_idx on objects using gist(path);


create table if not exists post_info(
    obj_id bigint primary key references objects (obj_id) on delete cascade ,
    num_comments integer default 0 not null,
    ref_id bigint
);create index if not exists post_obj_id_idx on post_info (obj_id);


create table if not exists likes(
    obj_id bigint references objects (obj_id) on delete cascade,
    auth_id bigint references users (user_id) on delete cascade,
    unique (obj_id, auth_id)
); create index if not exists likes_obj_id_idx on likes (obj_id);

/*-----------------------------------------------------------------------------------*/

CREATE FUNCTION insert_object_before_process() RETURNS trigger AS $insert_object_before_process$
    BEGIN
        new.path = new.path || new.obj_id::text;
       	return new;
    END;
$insert_object_before_process$ LANGUAGE plpgsql;
CREATE TRIGGER insert_object_before_trigger
	BEFORE INSERT ON objects
FOR EACH ROW EXECUTE PROCEDURE insert_object_before_process ();

CREATE FUNCTION insert_object_after_process() RETURNS trigger AS $insert_object_after_process$
    BEGIN
        if new.path::text = new.obj_id::text then /*post*/
            insert into post_info (obj_id) values (new.obj_id); /*добавляем строку в post_info*/
        else /*comment*/
            update post_info
                set num_comments = num_comments + 1
            where post_info.obj_id = ltree2text(subpath(new.path,0, 1))::bigint;
        end if;

       	Return new;
    END;
$insert_object_after_process$ LANGUAGE plpgsql;
CREATE TRIGGER insert_object_after_trigger
	AFTER INSERT ON objects
FOR EACH ROW EXECUTE PROCEDURE insert_object_after_process ();

CREATE FUNCTION add_like_process() RETURNS trigger AS $add_like_process$
    begin
       	update objects
            set num_likes = num_likes + 1
        where objects.obj_id = new.obj_id;
       	return new;
    end;
$add_like_process$ LANGUAGE plpgsql;
CREATE TRIGGER add_like_to_post_trigger
	AFTER INSERT ON likes
FOR EACH ROW EXECUTE PROCEDURE add_like_process ();


CREATE FUNCTION delete_post_process() RETURNS trigger AS $delete_post_process$
    begin
       	delete from objects where path <@ old.path;
       	return new;
    end;
$delete_post_process$ LANGUAGE plpgsql;
CREATE TRIGGER delete_post_trigger
	AFTER DELETE ON objects
FOR EACH ROW EXECUTE PROCEDURE delete_post_process ();


CREATE FUNCTION update_post_text_process() RETURNS trigger AS $update_post_text_process$
    BEGIN
       IF new.text <> old.text
        then
            new.modification_time = now();
       end if;
       return new;
    END;
$update_post_text_process$ LANGUAGE plpgsql;
CREATE TRIGGER update_post_text_trigger
	BEFORE UPDATE ON objects
FOR EACH ROW EXECUTE PROCEDURE update_post_text_process ();



/*Регистрируемся*/
insert into users (email, token, first_name, last_name, sex) values ('baranenkovs@mail.ru', E'\a','Vladimir','Putin', 'М');

/*добавляем посты*/
insert into objects (auth_id, text, path) values (1, 'Привет ребята!', '');
insert into objects (auth_id, text, path) values (1, 'Hello guys!', '');

/*добавляем комменты*/
insert into objects (auth_id, text, path) values (1, 'Привет ребята!', '1');
insert into objects (auth_id, text, path) values (1, 'Hello guys!', '2');

insert into objects (auth_id, text, path) values (1, 'Привет брух!', '1.3');
insert into objects (auth_id, text, path) values (1, 'Hello gays!', '2.4');


/*Добавляем лайки*/
insert into likes (obj_id, auth_id) values (1,1);
insert into likes (obj_id, auth_id) values (2,1);

insert into likes (obj_id, auth_id) values (3,1);
insert into likes (obj_id, auth_id) values (4,1);

/*Удаляем пост*/

/*delete from objects where obj_id = 1;*/


CREATE OR REPLACE FUNCTION get_comments(post_path text) RETURNS json AS $$
        BEGIN
            return (
select array_to_json(array_agg(res))
    from (
            WITH RECURSIVE
                c AS (
                    SELECT text,
                           num_likes,
                           path,
                           first_name,
                           last_name,
                           to_char(creation_time at time zone 'Europe/Moscow', 'DD.MM.YY HH24:MI') as creation_time,
                           to_char(modification_time at time zone 'Europe/Moscow', 'DD.MM.YY HH24:MI') as modification_time,
                           nlevel(path) AS lvl
                    FROM objects join users on user_id = auth_id where path <@ text2ltree(post_path)
                ),
                maxlvl AS (
                    SELECT max(lvl) maxlvl
                    FROM c
                ),
                j AS (
                    SELECT c.*,
                           json '[]' AS children
                    FROM c,
                         maxlvl
                    WHERE lvl = maxlvl
                    UNION ALL
                    SELECT (c).*,
                           CASE
                               WHEN COUNT(j) > 0
                                   THEN json_agg(j)
                               ELSE json '[]'
                               END AS children
                    FROM (
                             SELECT c,
                                    CASE
                                        WHEN c.path = subpath(j.path, 0, nlevel(j.path) - 1)
                                            THEN j
                                        END AS j
                             FROM j
                                      JOIN c ON c.lvl = j.lvl - 1
                         ) AS v
                    GROUP BY v.c
                )
            SELECT *
            FROM j
            WHERE lvl = 2
        ) res
                );
        end;
    $$ PARALLEL SAFE LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION get_posts(u_id bigint) returns json as $$
        begin
            return
                (
select array_to_json(array_agg(row_to_json(t)))
    from (
      select p.text,
             p.num_likes,
             pi.num_comments,
             pi.ref_id,
             to_char(p.creation_time at time zone 'Europe/Moscow', 'DD.MM.YY HH24:MI') as creation_time,
             to_char(p.modification_time at time zone 'Europe/Moscow', 'DD.MM.YY HH24:MI') as modification_time,
             u.first_name,
             u.last_name
      from objects p join users u on u.user_id = p.auth_id join post_info pi on p.obj_id = pi.obj_id where u.user_id = u_id
    ) t
        );
        end;
    $$ PARALLEL SAFE LANGUAGE plpgsql;

